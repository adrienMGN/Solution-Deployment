// Module de gestion audio
(function () {
    'use strict';

    // Variables locales pour l'audio
    let mediaRecorder;
    let audioChunks = [];
    let currentAudio = null;
    let isRecording = false;
    let audioStream = null;
    let isInitialized = false;

    // Fonctions utilitaires int√©gr√©es
    function showError(elementId, message) {
        const errorElement = document.getElementById(elementId);
        if (errorElement) {
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        } else {
            console.error('Error:', message);
        }
    }

    function hideError(elementId) {
        const errorElement = document.getElementById(elementId);
        if (errorElement) {
            errorElement.style.display = 'none';
        }
    }

    function showSuccess(elementId, message) {
        const successElement = document.getElementById(elementId);
        if (successElement) {
            successElement.textContent = message;
            successElement.style.display = 'block';
        } else {
            console.log('Success:', message);
        }
    }

    function hideSuccess(elementId) {
        const successElement = document.getElementById(elementId);
        if (successElement) {
            successElement.style.display = 'none';
        }
    }

    // Interface publique du module audio
    const audioModule = {
        async initializeAudio() {
            if (isInitialized) {
                console.log('Audio already initialized');
                return;
            }

            try {
                console.log('üé§ Initializing audio...');

                // Demander l'acc√®s au microphone
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    }
                });

                console.log('‚úÖ Audio stream obtained');

                // Configurer MediaRecorder
                const options = {
                    mimeType: 'audio/webm;codecs=opus'
                };

                // V√©rifier le support du format
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/webm';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'audio/mp4';
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            options.mimeType = '';
                        }
                    }
                }

                mediaRecorder = new MediaRecorder(audioStream, options);

                // √âv√©nements du MediaRecorder
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        console.log('üìä Audio data chunk received:', event.data.size, 'bytes');
                    }
                };

                mediaRecorder.onstop = () => {
                    console.log('üõë Recording stopped');
                    this.processRecording();
                };

                mediaRecorder.onerror = (event) => {
                    console.error('‚ùå MediaRecorder error:', event.error);
                    showError('recordingError', 'Recording error: ' + event.error.message);
                };

                // Mettre √† jour l'√©tat global
                if (window.appState) {
                    window.appState.setAudioStream(audioStream);
                    window.appState.setMediaRecorder(mediaRecorder);
                }

                isInitialized = true;
                console.log('‚úÖ MediaRecorder initialized with format:', options.mimeType);
                this.updateRecordingControls();

            } catch (error) {
                console.error('‚ùå Error initializing audio:', error);
                let errorMessage = 'Failed to access microphone. ';

                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Please allow microphone access and reload the page.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No microphone found on this device.';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage += 'Audio recording is not supported in this browser.';
                } else {
                    errorMessage += error.message;
                }

                showError('recordingError', errorMessage);
                throw error;
            }
        },

        async startRecording() {
            try {
                console.log('üéôÔ∏è Starting recording...');

                // Initialiser l'audio si ce n'est pas d√©j√† fait
                if (!isInitialized || !mediaRecorder) {
                    await this.initializeAudio();
                }

                if (!mediaRecorder) {
                    throw new Error('MediaRecorder initialization failed');
                }

                if (mediaRecorder.state !== 'inactive') {
                    throw new Error('MediaRecorder is not in inactive state');
                }

                // R√©initialiser les chunks audio
                audioChunks = [];
                if (window.appState) {
                    window.appState.setAudioChunks([]);
                }

                // Commencer l'enregistrement
                mediaRecorder.start(100); // Enregistrer par chunks de 100ms
                isRecording = true;

                if (window.appState) {
                    window.appState.setIsRecording(true);
                }

                console.log('‚úÖ Recording started');
                this.updateRecordingControls();
                this.updateRecordingIndicator();

                // Masquer les messages d'erreur pr√©c√©dents
                hideError('recordingError');

            } catch (error) {
                console.error('‚ùå Error starting recording:', error);
                showError('recordingError', 'Failed to start recording: ' + error.message);
            }
        },

        stopRecording() {
            try {
                console.log('üõë Stopping recording...');

                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    isRecording = false;

                    if (window.appState) {
                        window.appState.setIsRecording(false);
                    }

                    console.log('‚úÖ Recording stopped');
                } else {
                    console.warn('‚ö†Ô∏è MediaRecorder not recording');
                }

                this.updateRecordingControls();
                this.updateRecordingIndicator();

            } catch (error) {
                console.error('‚ùå Error stopping recording:', error);
                showError('recordingError', 'Failed to stop recording: ' + error.message);
            }
        },

        processRecording() {
            try {
                if (audioChunks.length === 0) {
                    console.warn('‚ö†Ô∏è No audio data to process');
                    return;
                }

                console.log('üîÑ Processing recording...');

                // Cr√©er un blob audio
                const audioBlob = new Blob(audioChunks, {
                    type: mediaRecorder.mimeType || 'audio/webm'
                });

                console.log('üìä Audio blob created:', audioBlob.size, 'bytes');

                // Cr√©er une URL pour la lecture
                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudio = new Audio(audioUrl);

                if (window.appState) {
                    window.appState.setCurrentAudio(currentAudio);
                }

                console.log('‚úÖ Recording processed successfully');
                this.updateRecordingControls();

                // Afficher un message de succ√®s
                showSuccess('recordingSuccess', 'Recording completed! You can now play it back or save it.');

            } catch (error) {
                console.error('‚ùå Error processing recording:', error);
                showError('recordingError', 'Failed to process recording: ' + error.message);
            }
        },

        playRecording() {
            try {
                if (!currentAudio) {
                    console.warn('‚ö†Ô∏è No audio to play');
                    return;
                }

                console.log('‚ñ∂Ô∏è Playing recording...');

                currentAudio.currentTime = 0;
                currentAudio.play();

                // √âv√©nements de lecture
                currentAudio.onended = () => {
                    console.log('‚úÖ Playback finished');
                };

                currentAudio.onerror = (error) => {
                    console.error('‚ùå Playback error:', error);
                    showError('recordingError', 'Failed to play recording');
                };

            } catch (error) {
                console.error('‚ùå Error playing recording:', error);
                showError('recordingError', 'Failed to play recording: ' + error.message);
            }
        },

        async saveRecording() {
            try {
                if (!currentAudio || audioChunks.length === 0) {
                    console.warn('‚ö†Ô∏è No recording to save');
                    return;
                }

                const sessionId = window.appState?.getSessionId();
                const currentSentenceIndex = window.appState?.getCurrentSentenceIndex() || 0;
                const sentences = window.appState?.getSentences() || [];

                if (!sessionId) {
                    throw new Error('No session ID available');
                }

                console.log('üíæ Saving recording...', {
                    sessionId,
                    sentenceIndex: currentSentenceIndex,
                    audioSize: audioChunks.reduce((total, chunk) => total + chunk.size, 0)
                });

                // Cr√©er le blob audio
                const audioBlob = new Blob(audioChunks, {
                    type: mediaRecorder.mimeType || 'audio/webm'
                });

                // Pr√©parer les donn√©es du formulaire
                const formData = new FormData();
                formData.append('audio', audioBlob, `recording_${sessionId}_${currentSentenceIndex}.webm`);
                formData.append('sessionId', sessionId);
                formData.append('sentenceIndex', currentSentenceIndex.toString());
                formData.append('sentence', sentences[currentSentenceIndex] || '');

                // Envoyer au serveur
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Upload failed');
                }

                const result = await response.json();
                console.log('‚úÖ Recording saved successfully:', result);

                // Mettre √† jour le compteur
                const completedRecordings = result.completedRecordings || (window.appState?.getCompletedRecordings() + 1);
                if (window.appState) {
                    window.appState.setCompletedRecordings(completedRecordings);
                }

                // Passer √† la phrase suivante automatiquement
                await this.nextSentence();

                // Afficher un message de succ√®s
                showSuccess('recordingSuccess', 'Recording saved successfully!');

            } catch (error) {
                console.error('‚ùå Error saving recording:', error);
                showError('recordingError', 'Failed to save recording: ' + error.message);
            }
        },

        async nextSentence() {
            try {
                const currentIndex = window.appState?.getCurrentSentenceIndex() || 0;
                const sentences = window.appState?.getSentences() || [];
                const totalSentences = sentences.length;

                console.log('‚û°Ô∏è Moving to next sentence:', currentIndex + 1, 'of', totalSentences);

                if (currentIndex + 1 >= totalSentences) {
                    // Session termin√©e
                    await this.completeSession();
                    return;
                }

                // Passer √† la phrase suivante
                const nextIndex = currentIndex + 1;
                if (window.appState) {
                    window.appState.setCurrentSentenceIndex(nextIndex);
                }

                // R√©initialiser l'enregistrement
                this.resetRecording();

                // Mettre √† jour l'affichage
                this.updateSentenceDisplay();
                this.updateProgressDisplay();

                console.log('‚úÖ Moved to sentence', nextIndex + 1);

            } catch (error) {
                console.error('‚ùå Error moving to next sentence:', error);
                showError('recordingError', 'Failed to move to next sentence: ' + error.message);
            }
        },

        async completeSession() {
            try {
                const sessionId = window.appState?.getSessionId();

                if (!sessionId) {
                    console.warn('‚ö†Ô∏è No session to complete');
                    return;
                }

                console.log('üéâ Completing session:', sessionId);

                // Arr√™ter le stream audio
                if (audioStream) {
                    audioStream.getTracks().forEach(track => track.stop());
                }

                // Envoyer la completion au serveur
                const response = await fetch('/api/session/complete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ sessionId })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to complete session');
                }

                const result = await response.json();
                console.log('‚úÖ Session completed:', result);

                // Calculer la dur√©e de la session
                const sessionStartTime = window.appState?.getSessionStartTime();
                const sessionDuration = sessionStartTime ? Math.round((Date.now() - sessionStartTime) / 60000) : 0;

                // Afficher la page de completion si le module pages existe
                if (window.pagesModule) {
                    window.pagesModule.showCompletionPage(result.completedRecordings, sessionDuration);
                } else {
                    alert(`Session completed! ${result.completedRecordings} recordings in ${sessionDuration} minutes.`);
                    location.reload();
                }

            } catch (error) {
                console.error('‚ùå Error completing session:', error);
                showError('recordingError', 'Failed to complete session: ' + error.message);
            }
        },

        async endSessionEarly() {
            try {
                const sessionId = window.appState?.getSessionId();

                if (!sessionId) {
                    console.warn('‚ö†Ô∏è No session to end');
                    return;
                }

                console.log('üîö Ending session early:', sessionId);

                // Arr√™ter le stream audio
                if (audioStream) {
                    audioStream.getTracks().forEach(track => track.stop());
                }

                // Envoyer la fin de session au serveur
                const response = await fetch('/api/session/end', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ sessionId })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to end session');
                }

                console.log('‚úÖ Session ended early');

                // Nettoyer et retourner √† l'accueil
                this.cleanup();
                if (window.pagesModule) {
                    window.pagesModule.activatePage('homepage');
                }

            } catch (error) {
                console.error('‚ùå Error ending session early:', error);
                showError('recordingError', 'Failed to end session: ' + error.message);
            }
        },

        rerecordAudio() {
            try {
                console.log('üîÑ Re-recording audio...');

                // R√©initialiser l'enregistrement
                this.resetRecording();

                // Masquer les messages
                hideError('recordingError');
                hideSuccess('recordingSuccess');

                console.log('‚úÖ Ready for re-recording');

            } catch (error) {
                console.error('‚ùå Error preparing re-recording:', error);
                showError('recordingError', 'Failed to prepare re-recording: ' + error.message);
            }
        },

        resetRecording() {
            // Arr√™ter la lecture en cours
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                URL.revokeObjectURL(currentAudio.src);
                currentAudio = null;
            }

            // R√©initialiser les chunks
            audioChunks = [];
            isRecording = false;

            // Mettre √† jour l'√©tat global
            if (window.appState) {
                window.appState.setCurrentAudio(null);
                window.appState.setAudioChunks([]);
                window.appState.setIsRecording(false);
            }

            // Mettre √† jour les contr√¥les
            this.updateRecordingControls();
            this.updateRecordingIndicator();

            // Masquer les messages
            hideError('recordingError');
            hideSuccess('recordingSuccess');
        },

        updateRecordingControls() {
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const playBtn = document.getElementById('playBtn');
            const saveBtn = document.getElementById('saveBtn');
            const rerecordBtn = document.getElementById('rerecordBtn');

            if (!recordBtn || !stopBtn || !playBtn || !saveBtn || !rerecordBtn) {
                return;
            }

            const hasAudio = currentAudio !== null;
            const recording = isRecording;

            recordBtn.disabled = recording;
            stopBtn.disabled = !recording;
            playBtn.disabled = !hasAudio || recording;
            saveBtn.disabled = !hasAudio || recording;
            rerecordBtn.disabled = !hasAudio || recording;

            // Mettre √† jour le texte du bouton d'enregistrement
            recordBtn.textContent = recording ? 'Recording...' : 'Start Recording';
        },

        updateRecordingIndicator() {
            const indicator = document.getElementById('recordingIndicator');
            if (!indicator) return;

            indicator.className = 'status-indicator';
            if (isRecording) {
                indicator.classList.add('recording');
            } else if (currentAudio) {
                indicator.classList.add('ready');
            }
        },

        updateSentenceDisplay() {
            const sentenceDisplay = document.getElementById('sentenceDisplay');
            const currentSentenceNum = document.getElementById('currentSentenceNum');

            if (!sentenceDisplay || !currentSentenceNum) return;

            const sentences = window.appState?.getSentences() || [];
            const currentIndex = window.appState?.getCurrentSentenceIndex() || 0;

            if (sentences.length > 0 && currentIndex < sentences.length) {
                sentenceDisplay.textContent = sentences[currentIndex];
                currentSentenceNum.textContent = currentIndex + 1;
            } else {
                sentenceDisplay.textContent = 'Loading sentence...';
            }
        },

        updateProgressDisplay() {
            const progressFill = document.getElementById('progressFill');
            const totalSentences = document.getElementById('totalSentences');
            const completedCount = document.getElementById('completedCount');

            if (!progressFill || !totalSentences || !completedCount) return;

            const sentences = window.appState?.getSentences() || [];
            const completed = window.appState?.getCompletedRecordings() || 0;
            const total = sentences.length;

            totalSentences.textContent = total;
            completedCount.textContent = completed;

            const progressPercent = total > 0 ? (completed / total) * 100 : 0;
            progressFill.style.width = progressPercent + '%';
        },

        // Alias pour compatibilit√©
        resetRecordingInterface() {
            this.resetRecording();
        },

        // Nettoyage des ressources
        cleanup() {
            console.log('üßπ Cleaning up audio resources...');

            // Arr√™ter l'enregistrement si en cours
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }

            // Lib√©rer le stream audio
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }

            // Nettoyer l'audio actuel
            if (currentAudio) {
                currentAudio.pause();
                URL.revokeObjectURL(currentAudio.src);
                currentAudio = null;
            }

            // R√©initialiser les variables
            mediaRecorder = null;
            audioChunks = [];
            isRecording = false;
            isInitialized = false;

            console.log('‚úÖ Audio cleanup completed');
        }
    };

    // Exposer le module globalement
    window.audioModule = audioModule;

    console.log('üéµ Audio module loaded successfully');

})();